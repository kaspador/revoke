import type { ContractConfiguration, GeneratedContract, SecurityWarning, OptimizationSuggestion } from '@/types/deployment'
import { CONTRACT_FEATURES } from './contractFeatures'

export class SolidityGenerator {
  private config: ContractConfiguration
  private selectedFeatures: any[]
  
  constructor(config: ContractConfiguration) {
    this.config = config
    this.selectedFeatures = config.selectedFeatures.map(id => CONTRACT_FEATURES[id]).filter(Boolean)
  }

  generate(): GeneratedContract {
    const solidity = this.generateSolidityCode()
    const warnings = this.analyzeSecurityWarnings()
    const suggestions = this.generateOptimizations()
    
    return {
      id: this.generateId(),
      name: this.config.name,
      configuration: this.config,
      solidity,
      abi: [], // Would be generated by compilation
      bytecode: '', // Would be generated by compilation
      gasEstimate: this.estimateGas(),
      securityScore: this.calculateSecurityScore(),
      complexity: this.calculateComplexity(),
      warnings,
      suggestions,
      constructorParams: this.generateConstructorParams(),
      deploymentScript: this.generateDeploymentScript(),
      verificationCode: this.generateVerificationCode(),
      createdAt: new Date(),
      version: '1.0.0',
      compiler: '0.8.19'
    }
  }

  private generateSolidityCode(): string {
    const imports = this.generateImports()
    const contract = this.generateContractDeclaration()
    const stateVariables = this.generateStateVariables()
    const constructor = this.generateConstructor()
    const functions = this.generateFunctions()
    const modifiers = this.generateModifiers()
    const events = this.generateEvents()

    return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

${imports}

/**
 * @title ${this.config.name}
 * @dev ${this.getContractDescription()}
 * @custom:security-contact security@${this.config.name.toLowerCase()}.com
 */
${contract} {
${stateVariables}

${constructor}

${functions}

${modifiers}

${events}
}`
  }

  private generateImports(): string {
    const imports = new Set<string>()
    
    for (const feature of this.selectedFeatures) {
      feature.imports.forEach((imp: string) => imports.add(imp))
    }

    return Array.from(imports).map(imp => `import "${imp}";`).join('\n')
  }

  private generateContractDeclaration(): string {
    const inheritance = new Set<string>()
    
    for (const feature of this.selectedFeatures) {
      feature.inheritance.forEach((inh: string) => inheritance.add(inh))
    }

    const inheritanceList = Array.from(inheritance)
    const inheritanceString = inheritanceList.length > 0 ? ` is ${inheritanceList.join(', ')}` : ''
    
    return `contract ${this.config.name}${inheritanceString}`
  }

  private generateStateVariables(): string {
    const variables: string[] = []
    
    // Add feature-specific state variables
    for (const feature of this.selectedFeatures) {
      variables.push(...feature.stateVariables)
    }

    // Add configuration-specific variables
    if (this.config.standard === 'ERC20' && this.config.maxSupply) {
      variables.push(`    uint256 public maxSupply = ${this.config.maxSupply} * 10**${this.config.decimals || 18};`)
    }

    if (this.config.standard === 'ERC721' && this.config.maxTokens) {
      variables.push(`    uint256 public maxTokens = ${this.config.maxTokens};`)
      variables.push(`    uint256 public currentTokenId = 0;`)
    }

    if (this.config.baseURI) {
      variables.push(`    string private _baseTokenURI = "${this.config.baseURI}";`)
    }

    return variables.length > 0 ? '    ' + variables.join('\n    ') + '\n' : ''
  }

  private generateConstructor(): string {
    const constructorCalls: string[] = []
    const constructorBody: string[] = []
    
    // Collect constructor calls from features
    for (const feature of this.selectedFeatures) {
      constructorCalls.push(...feature.constructor)
    }

    // Add basic constructor parameters
    const params: string[] = []
    
    if (this.config.standard === 'ERC20' || this.config.standard === 'ERC721') {
      // Constructor parameters are handled by parent constructors
    }

    if (this.config.standard === 'ERC1155') {
      // ERC1155 constructor handled by parent
    }

    // Add initial supply minting for ERC20
    if (this.config.standard === 'ERC20' && this.config.initialSupply) {
      constructorBody.push(`        _mint(msg.sender, ${this.config.initialSupply} * 10**${this.config.decimals || 18});`)
    }

    // Add owner setup if not using AccessControl
    if (!this.config.selectedFeatures.includes('access-control') && 
        this.config.selectedFeatures.includes('ownable')) {
      constructorBody.push('        // Owner is set by Ownable constructor')
    }

    // Tax configuration
    if (this.config.selectedFeatures.includes('tax') && this.config.featureParameters?.taxReceiver) {
      constructorBody.push(`        taxReceiver = ${this.config.featureParameters.taxReceiver};`)
    }

    const constructorCallsString = constructorCalls.length > 0 ? `\n        ${constructorCalls.join('\n        ')}` : ''
    const constructorBodyString = constructorBody.length > 0 ? '\n        ' + constructorBody.join('\n        ') : ''

    return `    constructor()${constructorCallsString} {${constructorBodyString}
    }`
  }

  private generateFunctions(): string {
    const functions: string[] = []
    
    // Collect functions from features
    for (const feature of this.selectedFeatures) {
      functions.push(...feature.functions)
    }

    // Add standard functions based on token type
    if (this.config.standard === 'ERC20') {
      // Add decimals override if needed
      if (this.config.decimals !== 18) {
        functions.push(`    function decimals() public view virtual override returns (uint8) {
        return ${this.config.decimals};
    }`)
      }
    }

    if (this.config.standard === 'ERC721') {
      // Add minting function
      functions.push(`    function mint(address to) public onlyOwner {
        require(currentTokenId < maxTokens, "Max tokens reached");
        uint256 tokenId = currentTokenId++;
        _mint(to, tokenId);
    }`)

      // Add batch minting
      functions.push(`    function batchMint(address to, uint256 quantity) public onlyOwner {
        require(currentTokenId + quantity <= maxTokens, "Would exceed max tokens");
        for (uint256 i = 0; i < quantity; i++) {
            _mint(to, currentTokenId++);
        }
    }`)

      // Add base URI functions
      if (this.config.baseURI) {
        functions.push(`    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }`)

        functions.push(`    function setBaseURI(string calldata baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }`)
      }
    }

    if (this.config.standard === 'ERC1155') {
      // Add minting functions for ERC1155
      functions.push(`    function mint(address to, uint256 id, uint256 amount, bytes memory data) public onlyOwner {
        _mint(to, id, amount, data);
    }`)

      functions.push(`    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner {
        _mintBatch(to, ids, amounts, data);
    }`)
    }

    // Add utility functions
    functions.push(`    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }`)

    return functions.length > 0 ? '    ' + functions.join('\n\n    ') + '\n' : ''
  }

  private generateModifiers(): string {
    const modifiers = new Set<string>()
    
    for (const feature of this.selectedFeatures) {
      feature.modifiers.forEach((mod: string) => modifiers.add(mod))
    }

    // Add custom modifiers if needed
    const customModifiers: string[] = []
    
    if (this.config.standard === 'ERC721' && this.config.maxTokens) {
      customModifiers.push(`    modifier validTokenId(uint256 tokenId) {
        require(_exists(tokenId), "Token does not exist");
        _;
    }`)
    }

    return customModifiers.length > 0 ? '    ' + customModifiers.join('\n\n    ') + '\n' : ''
  }

  private generateEvents(): string {
    const events = new Set<string>()
    
    for (const feature of this.selectedFeatures) {
      feature.events.forEach((event: string) => events.add(event))
    }

    return events.size > 0 ? '    ' + Array.from(events).join('\n    ') + '\n' : ''
  }

  private getContractDescription(): string {
    const features = this.selectedFeatures.map(f => f.name).join(', ')
    const standard = this.config.standard
    return `${standard} token with the following features: ${features}`
  }

  private analyzeSecurityWarnings(): SecurityWarning[] {
    const warnings: SecurityWarning[] = []
    
    // Check for dangerous feature combinations
    const dangerousFeatures = this.selectedFeatures.filter(f => f.riskLevel === 'dangerous')
    const criticalFeatures = this.selectedFeatures.filter(f => f.riskLevel === 'critical')
    
    if (criticalFeatures.length > 0) {
      warnings.push({
        type: 'critical',
        title: 'Critical Features Detected',
        description: `Your contract includes critical features: ${criticalFeatures.map(f => f.name).join(', ')}`,
        recommendation: 'These features require thorough auditing before deployment',
        severity: 9
      })
    }

    if (dangerousFeatures.length > 2) {
      warnings.push({
        type: 'high',
        title: 'Multiple Dangerous Features',
        description: `Contract includes ${dangerousFeatures.length} dangerous features`,
        recommendation: 'Consider reducing complexity or implementing additional safeguards',
        severity: 7
      })
    }

    // Check for missing security features
    if (!this.config.selectedFeatures.includes('ownable') && 
        !this.config.selectedFeatures.includes('access-control')) {
      warnings.push({
        type: 'medium',
        title: 'No Access Control',
        description: 'Contract has no access control mechanism',
        recommendation: 'Add Ownable or AccessControl for admin functions',
        severity: 6
      })
    }

    // Check for tax without exemptions
    if (this.config.selectedFeatures.includes('tax') && 
        !this.config.featureParameters?.taxReceiver) {
      warnings.push({
        type: 'high',
        title: 'Tax Without Receiver',
        description: 'Tax feature enabled but no tax receiver configured',
        recommendation: 'Set a tax receiver address to avoid locked funds',
        severity: 8
      })
    }

    // Check for reflection with other complex features
    if (this.config.selectedFeatures.includes('reflection') && 
        (this.config.selectedFeatures.includes('tax') || this.config.selectedFeatures.includes('deflation'))) {
      warnings.push({
        type: 'critical',
        title: 'Complex Tokenomics Combination',
        description: 'Reflection combined with tax/deflation creates extremely complex mechanics',
        recommendation: 'Consider simplifying tokenomics or extensive testing',
        severity: 10
      })
    }

    return warnings
  }

  private generateOptimizations(): OptimizationSuggestion[] {
    const suggestions: OptimizationSuggestion[] = []
    
    // Gas optimization suggestions
    const complexFeatures = this.selectedFeatures.filter(f => f.complexity >= 5)
    if (complexFeatures.length > 3) {
      suggestions.push({
        type: 'gas',
        title: 'High Complexity Features',
        description: 'Multiple complex features will increase gas costs',
        impact: 'high',
        effort: 'moderate',
        gasReduction: 200000
      })
    }

    // Security suggestions
    if (this.selectedFeatures.some(f => f.auditRequired)) {
      suggestions.push({
        type: 'security',
        title: 'Audit Recommended',
        description: 'Some features require professional security auditing',
        impact: 'high',
        effort: 'complex'
      })
    }

    // Readability suggestions
    if (this.selectedFeatures.length > 8) {
      suggestions.push({
        type: 'readability',
        title: 'Feature Complexity',
        description: 'Consider splitting functionality into multiple contracts',
        impact: 'medium',
        effort: 'complex'
      })
    }

    return suggestions
  }

  private estimateGas(): number {
    let baseGas = 800000 // Base deployment cost
    
    for (const feature of this.selectedFeatures) {
      baseGas += feature.gasImpact
    }
    
    // Add complexity multiplier
    const complexityMultiplier = 1 + (this.calculateComplexity() / 20)
    return Math.round(baseGas * complexityMultiplier)
  }

  private calculateSecurityScore(): number {
    let score = 100
    
    // Deduct points for risky features
    for (const feature of this.selectedFeatures) {
      switch (feature.riskLevel) {
        case 'dangerous':
          score -= 15
          break
        case 'critical':
          score -= 25
          break
        case 'moderate':
          score -= 5
          break
      }
    }

    // Deduct points for missing security features
    if (!this.config.selectedFeatures.includes('ownable') && 
        !this.config.selectedFeatures.includes('access-control')) {
      score -= 20
    }

    // Bonus for security features
    if (this.config.selectedFeatures.includes('pausable')) {
      score += 5
    }

    return Math.max(0, Math.min(100, score))
  }

  private calculateComplexity(): number {
    return this.selectedFeatures.reduce((total, feature) => total + feature.complexity, 0)
  }

  private generateConstructorParams(): any[] {
    const params: any[] = []
    
    // Standard parameters are handled in constructor
    // Additional runtime parameters would be added here
    
    return params
  }

  private generateDeploymentScript(): string {
    return `// Deployment script for ${this.config.name}
const { ethers } = require("hardhat");

async function main() {
  const [deployer] = await ethers.getSigners();
  
  console.log("Deploying ${this.config.name} with account:", deployer.address);
  console.log("Account balance:", (await deployer.getBalance()).toString());

  const ${this.config.name} = await ethers.getContractFactory("${this.config.name}");
  const token = await ${this.config.name}.deploy();

  await token.deployed();

  console.log("${this.config.name} deployed to:", token.address);
  
  // Verify contract
  if (network.name !== "hardhat" && network.name !== "localhost") {
    console.log("Waiting for block confirmations...");
    await token.deployTransaction.wait(6);
    await verify(token.address, []);
  }
}

async function verify(contractAddress, args) {
  try {
    await run("verify:verify", {
      address: contractAddress,
      constructorArguments: args,
    });
  } catch (e) {
    if (e.message.toLowerCase().includes("already verified")) {
      console.log("Already verified!");
    } else {
      console.log(e);
    }
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });`
  }

  private generateVerificationCode(): string {
    return `npx hardhat verify --network mainnet ${this.config.name} ${this.generateConstructorParams().join(' ')}`
  }

  private generateId(): string {
    return `contract_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}

// Utility functions for code generation
export function generateRemixFiles(contract: GeneratedContract): RemixDeployment {
  return {
    contractName: contract.name,
    sourceCode: contract.solidity,
    compilerVersion: '0.8.19',
    evmVersion: contract.configuration.evmVersion,
    optimization: {
      enabled: true,
      runs: contract.configuration.optimizationRuns
    },
    constructorArgs: contract.constructorParams,
    libraries: {}
  }
}

export function exportToRemix(contract: GeneratedContract): string {
  const remixData = generateRemixFiles(contract)
  
  // Generate Remix workspace JSON
  const workspace = {
    "contracts": {
      [`${contract.name}.sol`]: {
        content: remixData.sourceCode
      }
    },
    "settings": {
      "optimizer": {
        "enabled": remixData.optimization.enabled,
        "runs": remixData.optimization.runs
      },
      "evmVersion": remixData.evmVersion,
      "compilerVersion": remixData.compilerVersion
    }
  }
  
  return JSON.stringify(workspace, null, 2)
}

export function generateHardhatConfig(contract: GeneratedContract): string {
  return `require("@nomicfoundation/hardhat-toolbox");
require("@nomiclabs/hardhat-etherscan");

module.exports = {
  solidity: {
    version: "${contract.compiler}",
    settings: {
      optimizer: {
        enabled: true,
        runs: ${contract.configuration.optimizationRuns}
      },
      evmVersion: "${contract.configuration.evmVersion}"
    }
  },
  networks: {
    hardhat: {},
    mainnet: {
      url: process.env.MAINNET_URL || "",
      accounts: process.env.PRIVATE_KEY !== undefined ? [process.env.PRIVATE_KEY] : [],
    }
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};`
}
