import type { ContractConfiguration, GeneratedContract, SecurityWarning, OptimizationSuggestion, RemixDeployment } from '@/types/deployment'
import { CONTRACT_FEATURES } from './contractFeatures'

export class SolidityGenerator {
  private config: ContractConfiguration
  private selectedFeatures: any[]
  
  constructor(config: ContractConfiguration) {
    this.config = config
    this.selectedFeatures = config.selectedFeatures.map(id => CONTRACT_FEATURES[id]).filter(Boolean)
  }

  generate(): GeneratedContract {
    const solidity = this.generateSolidityCode()
    const warnings = this.analyzeSecurityWarnings()
    const suggestions = this.generateOptimizations()
    
    return {
      id: this.generateId(),
      name: this.config.name,
      configuration: this.config,
      solidity,
      abi: [], // Would be generated by compilation
      bytecode: '', // Would be generated by compilation
      gasEstimate: this.estimateGas(),
      securityScore: this.calculateSecurityScore(),
      complexity: this.calculateComplexity(),
      warnings,
      suggestions,
      constructorParams: this.generateConstructorParams(),
      deploymentScript: this.generateDeploymentScript(),
      verificationCode: this.generateVerificationCode(),
      createdAt: new Date(),
      version: '1.0.0',
      compiler: '0.8.19'
    }
  }

  private generateSolidityCode(): string {
    const imports = this.generateImports()
    const contract = this.generateContractDeclaration()
    const stateVariables = this.generateStateVariables()
    const constructor = this.generateConstructor()
    const functions = this.generateFunctions()
    const modifiers = this.generateModifiers()
    const events = this.generateEvents()

    return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

${imports}

/**
 * @title ${this.config.name}
 * @dev ${this.getContractDescription()}
 * @custom:security-contact security@${this.config.name.toLowerCase()}.com
 */
${contract} {
${stateVariables}

${constructor}

${functions}

${modifiers}

${events}
}`
  }

  private generateImports(): string {
    const imports = new Set<string>()
    
    // Add base imports based on token standard
    if (this.config.standard === 'ERC20') {
      imports.add('@openzeppelin/contracts/token/ERC20/ERC20.sol')
    }
    if (this.config.standard === 'ERC721') {
      imports.add('@openzeppelin/contracts/token/ERC721/ERC721.sol')
    }
    if (this.config.standard === 'ERC1155') {
      imports.add('@openzeppelin/contracts/token/ERC1155/ERC1155.sol')
    }
    
    // Add feature-specific imports
    for (const feature of this.selectedFeatures) {
      feature.imports.forEach((imp: string) => imports.add(imp))
    }

    // Add required imports based on selected features
    if (this.config.selectedFeatures.includes('burnable')) {
      imports.add('@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol')
    }
    if (this.config.selectedFeatures.includes('pausable')) {
      imports.add('@openzeppelin/contracts/security/Pausable.sol')
    }
    if (this.config.selectedFeatures.includes('ownable')) {
      imports.add('@openzeppelin/contracts/access/Ownable.sol')
    }
    if (this.config.selectedFeatures.includes('access-control')) {
      imports.add('@openzeppelin/contracts/access/AccessControl.sol')
    }
    if (this.config.selectedFeatures.includes('snapshot')) {
      imports.add('@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol')
    }
    if (this.config.selectedFeatures.includes('permit')) {
      imports.add('@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol')
    }
    if (this.config.selectedFeatures.includes('votes')) {
      imports.add('@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol')
    }

    return Array.from(imports).map(imp => `import "${imp}";`).join('\n')
  }

  private generateContractDeclaration(): string {
    const inheritance: string[] = []
    
    // Add base token standard first
    if (this.config.standard === 'ERC20') {
      inheritance.push('ERC20')
    } else if (this.config.standard === 'ERC721') {
      inheritance.push('ERC721')
    } else if (this.config.standard === 'ERC1155') {
      inheritance.push('ERC1155')
    }
    
    // Add extensions in proper order to avoid conflicts
    if (this.config.selectedFeatures.includes('burnable')) {
      inheritance.push('ERC20Burnable')
    }
    if (this.config.selectedFeatures.includes('ownable')) {
      inheritance.push('Ownable')
    }
    if (this.config.selectedFeatures.includes('access-control')) {
      inheritance.push('AccessControl')
    }
    if (this.config.selectedFeatures.includes('pausable')) {
      inheritance.push('Pausable')
    }
    if (this.config.selectedFeatures.includes('snapshot')) {
      inheritance.push('ERC20Snapshot')
    }
    if (this.config.selectedFeatures.includes('permit')) {
      inheritance.push('ERC20Permit')
    }
    if (this.config.selectedFeatures.includes('votes')) {
      inheritance.push('ERC20Votes')
    }
    
    // Add any additional inheritance from features (avoiding duplicates)
    const additionalInheritance = new Set<string>()
    for (const feature of this.selectedFeatures) {
      feature.inheritance.forEach((inh: string) => {
        if (!inheritance.includes(inh)) {
          additionalInheritance.add(inh)
        }
      })
    }
    inheritance.push(...Array.from(additionalInheritance))

    const inheritanceString = inheritance.length > 0 ? ` is ${inheritance.join(', ')}` : ''
    
    return `contract ${this.config.name}${inheritanceString}`
  }

  private generateStateVariables(): string {
    const variables: string[] = []
    
    // Add feature-specific state variables with proper indentation
    for (const feature of this.selectedFeatures) {
      for (const variable of feature.stateVariables) {
        // Ensure proper indentation - add 4 spaces if not already indented
        const indentedVariable = variable.startsWith('    ') ? variable : `    ${variable}`
        variables.push(indentedVariable)
      }
    }

    // Add configuration-specific variables
    if (this.config.standard === 'ERC20' && this.config.maxSupply) {
      variables.push(`    uint256 public maxSupply = ${this.config.maxSupply} * 10**${this.config.decimals || 18};`)
    }

    if (this.config.standard === 'ERC721' && this.config.maxTokens) {
      variables.push(`    uint256 public maxTokens = ${this.config.maxTokens};`)
      variables.push(`    uint256 public currentTokenId = 0;`)
    }

    if (this.config.baseURI) {
      variables.push(`    string private _baseTokenURI = "${this.config.baseURI}";`)
    }

    // Add feature parameter-based variables
    if (this.config.featureParameters) {
      const params = this.config.featureParameters
      
      // Tax feature parameters
      if (this.config.selectedFeatures.includes('tax')) {
        if (params.taxRate !== undefined) {
          variables.push(`    uint256 public taxRate = ${params.taxRate}; // Tax rate in basis points (100 = 1%)`)
        }
        if (params.taxReceiver) {
          variables.push(`    address public taxReceiver = ${params.taxReceiver};`)
        }
      }
      
      // Deflation feature parameters
      if (this.config.selectedFeatures.includes('deflation')) {
        if (params.burnRate !== undefined) {
          variables.push(`    uint256 public burnRate = ${params.burnRate}; // Burn rate in basis points`)
        }
      }
      
      // Max transaction/wallet limits
      if (params.maxTransaction) {
        variables.push(`    uint256 public maxTransaction = ${params.maxTransaction} * 10**${this.config.decimals || 18};`)
      }
      if (params.maxWallet) {
        variables.push(`    uint256 public maxWallet = ${params.maxWallet} * 10**${this.config.decimals || 18};`)
      }
    }

    return variables.length > 0 ? variables.join('\n') + '\n' : ''
  }

  private generateConstructor(): string {
    const constructorCalls: string[] = []
    const constructorBody: string[] = []
    const constructorParams: string[] = []
    
    // Add constructor parameters based on token standard
    if (this.config.standard === 'ERC20' || this.config.standard === 'ERC721') {
      constructorParams.push('string memory _name', 'string memory _symbol')
    }

    if (this.config.standard === 'ERC1155') {
      constructorParams.push('string memory _uri')
    }
    
    // Add constructor calls in proper order
    if (this.config.standard === 'ERC20' || this.config.standard === 'ERC721') {
      constructorCalls.push('ERC20(_name, _symbol)')
    }
    if (this.config.standard === 'ERC1155') {
      constructorCalls.push('ERC1155(_uri)')
    }
    
    // Add ERC20Permit constructor if permit feature is enabled
    if (this.config.selectedFeatures.includes('permit')) {
      constructorCalls.push('ERC20Permit(_name)')
    }
    
    // Collect additional constructor calls from features
    for (const feature of this.selectedFeatures) {
      const calls = feature.constructor.map((call: string) => {
        // Skip base ERC20 and ERC20Permit calls as we handle them above
        if (call.includes('ERC20(_name, _symbol)') || call.includes('ERC20Permit(_name)')) {
          return ''
        }
        // Replace parameter placeholders with actual parameter names
        return call.replace('_name', '_name').replace('_symbol', '_symbol').replace('_uri', '_uri')
      }).filter((call: string) => call.trim() !== '')
      constructorCalls.push(...calls)
    }

    // Add initial supply minting for ERC20
    if (this.config.standard === 'ERC20' && this.config.initialSupply) {
      constructorBody.push(`        _mint(msg.sender, ${this.config.initialSupply} * 10**${this.config.decimals || 18});`)
    }

    // Add owner setup if not using AccessControl
    if (!this.config.selectedFeatures.includes('access-control') && 
        this.config.selectedFeatures.includes('ownable')) {
      constructorBody.push('        // Owner is set by Ownable constructor')
    }

    // Tax configuration
    if (this.config.selectedFeatures.includes('tax') && this.config.featureParameters?.taxReceiver) {
      constructorBody.push(`        taxReceiver = ${this.config.featureParameters.taxReceiver};`)
    }

    const paramsString = constructorParams.length > 0 ? constructorParams.join(', ') : ''
    const constructorCallsString = constructorCalls.length > 0 ? `\n        ${constructorCalls.join('\n        ')}` : ''
    const constructorBodyString = constructorBody.length > 0 ? '\n        ' + constructorBody.join('\n        ') : ''

    return `    constructor(${paramsString})${constructorCallsString} {${constructorBodyString}
    }`
  }

  private generateFunctions(): string {
    const functions: string[] = []
    const functionSignatures = new Set<string>() // Track function signatures to avoid duplicates
    
    // Collect functions from features with proper indentation and conflict resolution
    for (const feature of this.selectedFeatures) {
      for (const func of feature.functions) {
        // Ensure proper indentation
        const indentedFunc = this.ensureProperIndentation(func)
        
        // Extract function signature for duplicate detection
        const signature = this.extractFunctionSignature(indentedFunc)
        
        if (!functionSignatures.has(signature)) {
          functions.push(indentedFunc)
          functionSignatures.add(signature)
        } else {
          // Handle function override - later features override earlier ones
          const existingIndex = functions.findIndex(f => this.extractFunctionSignature(f) === signature)
          if (existingIndex !== -1) {
            functions[existingIndex] = indentedFunc // Override with newer implementation
          }
        }
      }
    }

    // Add standard functions based on token type (only if not already provided by features)
    if (this.config.standard === 'ERC20') {
      // Add decimals override if needed and not already defined
      if (this.config.decimals !== 18 && !functionSignatures.has('decimals()')) {
        functions.push(`    function decimals() public view virtual override returns (uint8) {
        return ${this.config.decimals};
    }`)
      }
    }

    if (this.config.standard === 'ERC721') {
      // Add minting function only if not provided by features
      if (!functionSignatures.has('mint(address)') && !this.config.selectedFeatures.includes('mintable')) {
        functions.push(`    function mint(address to) public onlyOwner {
        require(currentTokenId < maxTokens, "Max tokens reached");
        uint256 tokenId = currentTokenId++;
        _mint(to, tokenId);
    }`)
      }

      // Add batch minting only if not provided
      if (!functionSignatures.has('batchMint(address,uint256)')) {
        functions.push(`    function batchMint(address to, uint256 quantity) public onlyOwner {
        require(currentTokenId + quantity <= maxTokens, "Would exceed max tokens");
        for (uint256 i = 0; i < quantity; i++) {
            _mint(to, currentTokenId++);
        }
    }`)
      }

      // Add base URI functions if configured and not provided by features
      if (this.config.baseURI && !functionSignatures.has('_baseURI()')) {
        functions.push(`    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }`)
      }

      if (this.config.baseURI && !functionSignatures.has('setBaseURI(string)')) {
        functions.push(`    function setBaseURI(string calldata baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }`)
      }
    }

    if (this.config.standard === 'ERC1155') {
      // Add minting functions for ERC1155 only if not provided by features
      if (!functionSignatures.has('mint(address,uint256,uint256,bytes)') && !this.config.selectedFeatures.includes('mintable')) {
        functions.push(`    function mint(address to, uint256 id, uint256 amount, bytes memory data) public onlyOwner {
        _mint(to, id, amount, data);
    }`)
      }

      if (!functionSignatures.has('mintBatch(address,uint256[],uint256[],bytes)')) {
        functions.push(`    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner {
        _mintBatch(to, ids, amounts, data);
    }`)
      }
    }

    // Add utility functions only if not already provided
    if (!functionSignatures.has('withdraw()')) {
      functions.push(`    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }`)
    }

    // Handle complex function conflicts (like multiple _transfer implementations)
    const resolvedFunctions = this.handleComplexFunctionConflicts(functions)
    
    // Add required OpenZeppelin overrides
    const overrideFunctions = this.generateRequiredOverrides()
    resolvedFunctions.push(...overrideFunctions)
    
    return resolvedFunctions.length > 0 ? resolvedFunctions.join('\n\n') + '\n' : ''
  }

  private ensureProperIndentation(func: string): string {
    const lines = func.split('\n')
    return lines.map(line => {
      if (line.trim() === '') return line
      return line.startsWith('    ') ? line : `    ${line}`
    }).join('\n')
  }

  private extractFunctionSignature(func: string): string {
    // Extract function signature from function definition
    const match = func.match(/function\s+(\w+)\s*\([^)]*\)/)
    return match ? match[1] + '(' + (func.match(/\(([^)]*)\)/) || ['', ''])[1].replace(/\s+/g, '') + ')' : ''
  }

  private handleComplexFunctionConflicts(functions: string[]): string[] {
    // Handle special cases where multiple features need to modify the same function
    const transferFunctions = functions.filter(f => f.includes('function _transfer('))
    
    if (transferFunctions.length > 1) {
      // Merge multiple _transfer implementations
      const mergedTransfer = this.mergeTransferFunctions(transferFunctions)
      // Remove individual transfer functions and add merged one
      const otherFunctions = functions.filter(f => !f.includes('function _transfer('))
      return [...otherFunctions, mergedTransfer]
    }
    
    return functions
  }

  private mergeTransferFunctions(transferFunctions: string[]): string {
    // Create a comprehensive _transfer function that handles all features
    const hasReflection = this.config.selectedFeatures.includes('reflection')
    const hasTax = this.config.selectedFeatures.includes('tax')
    const hasDeflation = this.config.selectedFeatures.includes('deflation')
    const hasLimits = this.config.featureParameters?.maxTransaction || this.config.featureParameters?.maxWallet
    
    let transferLogic = `    function _transfer(address from, address to, uint256 amount) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");`

    // Add transaction limits
    if (hasLimits) {
      if (this.config.featureParameters?.maxTransaction) {
        transferLogic += `
        if (from != owner() && to != owner()) {
            require(amount <= maxTransaction, "Transfer amount exceeds maximum transaction");
        }`
      }
      
      if (this.config.featureParameters?.maxWallet) {
        transferLogic += `
        if (to != owner()) {
            require(balanceOf(to) + amount <= maxWallet, "Transfer would exceed maximum wallet");
        }`
      }
    }

    // Add tax logic with proper exemption checks
    if (hasTax) {
      transferLogic += `
        
        uint256 taxAmount = 0;
        uint256 transferAmount = amount;
        
        // Apply tax if not exempt and tax rate is set
        if (!isExemptFromTax[from] && !isExemptFromTax[to] && taxRate > 0 && taxReceiver != address(0)) {
            taxAmount = (amount * taxRate) / 10000;
            transferAmount = amount - taxAmount;
        }`
    } else {
      transferLogic += `
        
        uint256 transferAmount = amount;`
    }

    // Add deflation logic
    if (hasDeflation) {
      transferLogic += `
        
        uint256 burnAmount = 0;
        if (from != owner() && to != owner()) {
            burnAmount = (transferAmount * burnRate) / 10000;
            if (burnAmount > 0) {
                _burn(from, burnAmount);
                transferAmount -= burnAmount;
            }
        }`
    }

    // Add reflection logic (simplified)
    if (hasReflection) {
      transferLogic += `
        
        // Reflection logic - distribute to all holders
        if (from != owner() && to != owner()) {
            uint256 reflectionAmount = (transferAmount * reflectionRate) / 10000;
            if (reflectionAmount > 0) {
                _distributeReflection(reflectionAmount);
                transferAmount -= reflectionAmount;
            }
        }`
    }

    transferLogic += `
        
        // Execute the actual transfer
        super._transfer(from, to, transferAmount);`

    // Add tax transfer if applicable
    if (hasTax) {
      transferLogic += `
        
        // Transfer tax to receiver if applicable
        if (taxAmount > 0) {
            super._transfer(from, taxReceiver, taxAmount);
        }`
    }

    transferLogic += `
    }`

    return transferLogic
  }

  private generateRequiredOverrides(): string[] {
    const overrides: string[] = []
    
    // Add _beforeTokenTransfer override if pausable and snapshot are both used
    if (this.config.selectedFeatures.includes('pausable') && this.config.selectedFeatures.includes('snapshot')) {
      overrides.push(`    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal
        whenNotPaused
        override(ERC20, ERC20Snapshot)
    {
        super._beforeTokenTransfer(from, to, amount);
    }`)
    } else if (this.config.selectedFeatures.includes('pausable')) {
      overrides.push(`    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal
        whenNotPaused
        override
    {
        super._beforeTokenTransfer(from, to, amount);
    }`)
    } else if (this.config.selectedFeatures.includes('snapshot')) {
      overrides.push(`    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal
        override(ERC20, ERC20Snapshot)
    {
        super._beforeTokenTransfer(from, to, amount);
    }`)
    }

    // Add _afterTokenTransfer override if votes is used
    if (this.config.selectedFeatures.includes('votes')) {
      overrides.push(`    function _afterTokenTransfer(address from, address to, uint256 amount)
        internal
        override(ERC20, ERC20Votes)
    {
        super._afterTokenTransfer(from, to, amount);
    }`)
    }

    // Add _mint override if votes is used
    if (this.config.selectedFeatures.includes('votes')) {
      overrides.push(`    function _mint(address to, uint256 amount)
        internal
        override(ERC20, ERC20Votes)
    {
        super._mint(to, amount);
    }`)
    }

    // Add _burn override if votes is used
    if (this.config.selectedFeatures.includes('votes')) {
      overrides.push(`    function _burn(address account, uint256 amount)
        internal
        override(ERC20, ERC20Votes)
    {
        super._burn(account, amount);
    }`)
    }

    return overrides
  }

  private generateModifiers(): string {
    const modifiers: string[] = []
    const modifierNames = new Set<string>()
    
    // Collect modifiers from features with proper indentation
    for (const feature of this.selectedFeatures) {
      for (const mod of feature.modifiers) {
        // If it's just a modifier name (like 'onlyOwner'), skip it as it's inherited
        if (mod.includes('modifier ')) {
          const indentedMod = this.ensureProperIndentation(mod)
          const modName = this.extractModifierName(indentedMod)
          
          if (!modifierNames.has(modName)) {
            modifiers.push(indentedMod)
            modifierNames.add(modName)
          }
        }
      }
    }

    // Add custom modifiers based on configuration
    if (this.config.standard === 'ERC721' && this.config.maxTokens && !modifierNames.has('validTokenId')) {
      modifiers.push(`    modifier validTokenId(uint256 tokenId) {
        require(_exists(tokenId), "Token does not exist");
        _;
    }`)
    }

    // Add transaction limit modifiers if configured
    if (this.config.featureParameters?.maxTransaction && !modifierNames.has('belowMaxTx')) {
      modifiers.push(`    modifier belowMaxTx(uint256 amount) {
        require(amount <= maxTransaction, "Transfer amount exceeds maximum transaction");
        _;
    }`)
    }

    // Add wallet limit modifiers if configured  
    if (this.config.featureParameters?.maxWallet && !modifierNames.has('belowMaxWallet')) {
      modifiers.push(`    modifier belowMaxWallet(address to, uint256 amount) {
        require(balanceOf(to) + amount <= maxWallet, "Transfer would exceed maximum wallet");
        _;
    }`)
    }

    return modifiers.length > 0 ? modifiers.join('\n\n') + '\n' : ''
  }

  private extractModifierName(modifier: string): string {
    const match = modifier.match(/modifier\s+(\w+)\s*\(/)
    return match ? match[1] : ''
  }

  private generateEvents(): string {
    const events: string[] = []
    const eventSignatures = new Set<string>()
    
    // Add standard events based on features
    if (this.config.selectedFeatures.includes('tax')) {
      events.push('    event TaxRateUpdated(uint256 oldRate, uint256 newRate);')
      events.push('    event TaxReceiverUpdated(address oldReceiver, address newReceiver);')
      events.push('    event TaxExemptionSet(address account, bool exempt);')
      eventSignatures.add('TaxRateUpdated')
      eventSignatures.add('TaxReceiverUpdated') 
      eventSignatures.add('TaxExemptionSet')
    }
    
    if (this.config.selectedFeatures.includes('deflation')) {
      events.push('    event DeflationaryBurn(address indexed from, uint256 amount);')
      eventSignatures.add('DeflationaryBurn')
    }
    
    // Collect events from features with proper indentation
    for (const feature of this.selectedFeatures) {
      for (const event of feature.events) {
        const indentedEvent = this.ensureProperIndentation(event)
        const signature = this.extractEventSignature(indentedEvent)
        
        if (!eventSignatures.has(signature)) {
          events.push(indentedEvent)
          eventSignatures.add(signature)
        }
      }
    }

    return events.length > 0 ? events.join('\n') + '\n' : ''
  }

  private extractEventSignature(event: string): string {
    const match = event.match(/event\s+(\w+)\s*\([^)]*\)/)
    return match ? match[1] + '(' + (event.match(/\(([^)]*)\)/) || ['', ''])[1].replace(/\s+/g, '') + ')' : ''
  }

  private getContractDescription(): string {
    const features = this.selectedFeatures.map(f => f.name).join(', ')
    const standard = this.config.standard
    return `${standard} token with the following features: ${features}`
  }

  private analyzeSecurityWarnings(): SecurityWarning[] {
    const warnings: SecurityWarning[] = []
    
    // Check for dangerous feature combinations
    const dangerousFeatures = this.selectedFeatures.filter(f => f.riskLevel === 'dangerous')
    const criticalFeatures = this.selectedFeatures.filter(f => f.riskLevel === 'critical')
    
    if (criticalFeatures.length > 0) {
      warnings.push({
        type: 'critical',
        title: 'Critical Features Detected',
        description: `Your contract includes critical features: ${criticalFeatures.map(f => f.name).join(', ')}`,
        recommendation: 'These features require thorough auditing before deployment',
        severity: 9
      })
    }

    if (dangerousFeatures.length > 2) {
      warnings.push({
        type: 'high',
        title: 'Multiple Dangerous Features',
        description: `Contract includes ${dangerousFeatures.length} dangerous features`,
        recommendation: 'Consider reducing complexity or implementing additional safeguards',
        severity: 7
      })
    }

    // Check for missing security features
    if (!this.config.selectedFeatures.includes('ownable') && 
        !this.config.selectedFeatures.includes('access-control')) {
      warnings.push({
        type: 'medium',
        title: 'No Access Control',
        description: 'Contract has no access control mechanism',
        recommendation: 'Add Ownable or AccessControl for admin functions',
        severity: 6
      })
    }

    // Check for tax without exemptions
    if (this.config.selectedFeatures.includes('tax') && 
        !this.config.featureParameters?.taxReceiver) {
      warnings.push({
        type: 'high',
        title: 'Tax Without Receiver',
        description: 'Tax feature enabled but no tax receiver configured',
        recommendation: 'Set a tax receiver address to avoid locked funds',
        severity: 8
      })
    }

    // Check for reflection with other complex features
    if (this.config.selectedFeatures.includes('reflection') && 
        (this.config.selectedFeatures.includes('tax') || this.config.selectedFeatures.includes('deflation'))) {
      warnings.push({
        type: 'critical',
        title: 'Complex Tokenomics Combination',
        description: 'Reflection combined with tax/deflation creates extremely complex mechanics',
        recommendation: 'Consider simplifying tokenomics or extensive testing',
        severity: 10
      })
    }

    return warnings
  }

  private generateOptimizations(): OptimizationSuggestion[] {
    const suggestions: OptimizationSuggestion[] = []
    
    // Gas optimization suggestions
    const complexFeatures = this.selectedFeatures.filter(f => f.complexity >= 5)
    if (complexFeatures.length > 3) {
      suggestions.push({
        type: 'gas',
        title: 'High Complexity Features',
        description: 'Multiple complex features will increase gas costs',
        impact: 'high',
        effort: 'moderate',
        gasReduction: 200000
      })
    }

    // Security suggestions
    if (this.selectedFeatures.some(f => f.auditRequired)) {
      suggestions.push({
        type: 'security',
        title: 'Audit Recommended',
        description: 'Some features require professional security auditing',
        impact: 'high',
        effort: 'complex'
      })
    }

    // Readability suggestions
    if (this.selectedFeatures.length > 8) {
      suggestions.push({
        type: 'readability',
        title: 'Feature Complexity',
        description: 'Consider splitting functionality into multiple contracts',
        impact: 'medium',
        effort: 'complex'
      })
    }

    return suggestions
  }

  private estimateGas(): number {
    let baseGas = 800000 // Base deployment cost
    
    for (const feature of this.selectedFeatures) {
      baseGas += feature.gasImpact
    }
    
    // Add complexity multiplier
    const complexityMultiplier = 1 + (this.calculateComplexity() / 20)
    return Math.round(baseGas * complexityMultiplier)
  }

  private calculateSecurityScore(): number {
    let score = 100
    
    // Deduct points for risky features
    for (const feature of this.selectedFeatures) {
      switch (feature.riskLevel) {
        case 'dangerous':
          score -= 15
          break
        case 'critical':
          score -= 25
          break
        case 'moderate':
          score -= 5
          break
      }
    }

    // Deduct points for missing security features
    if (!this.config.selectedFeatures.includes('ownable') && 
        !this.config.selectedFeatures.includes('access-control')) {
      score -= 20
    }

    // Bonus for security features
    if (this.config.selectedFeatures.includes('pausable')) {
      score += 5
    }

    return Math.max(0, Math.min(100, score))
  }

  private calculateComplexity(): number {
    return this.selectedFeatures.reduce((total, feature) => total + feature.complexity, 0)
  }

  private generateConstructorParams(): any[] {
    const params: any[] = []
    
    // Add standard parameters based on token type
    if (this.config.standard === 'ERC20' || this.config.standard === 'ERC721') {
      params.push(this.config.name || 'MyToken')
      params.push(this.config.symbol || 'MTK')
    }

    if (this.config.standard === 'ERC1155') {
      params.push(this.config.baseURI || 'https://api.example.com/metadata/{id}.json')
    }
    
    return params
  }

  private generateDeploymentScript(): string {
    const constructorArgs = this.generateConstructorParams()
    const argsString = constructorArgs.map(arg => `"${arg}"`).join(', ')
    
    return `// Deployment script for ${this.config.name}
const { ethers } = require("hardhat");

async function main() {
  const [deployer] = await ethers.getSigners();
  
  console.log("Deploying ${this.config.name} with account:", deployer.address);
  console.log("Account balance:", (await deployer.getBalance()).toString());

  const ${this.config.name} = await ethers.getContractFactory("${this.config.name}");
  const token = await ${this.config.name}.deploy(${argsString});

  await token.deployed();

  console.log("${this.config.name} deployed to:", token.address);
  
  // Verify contract
  if (network.name !== "hardhat" && network.name !== "localhost") {
    console.log("Waiting for block confirmations...");
    await token.deployTransaction.wait(6);
    await verify(token.address, [${argsString}]);
  }
}

async function verify(contractAddress, args) {
  try {
    await run("verify:verify", {
      address: contractAddress,
      constructorArguments: args,
    });
  } catch (e) {
    if (e.message.toLowerCase().includes("already verified")) {
      console.log("Already verified!");
    } else {
      console.log(e);
    }
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });`
  }

  private generateVerificationCode(): string {
    const constructorArgs = this.generateConstructorParams()
    const argsString = constructorArgs.map(arg => `"${arg}"`).join(' ')
    return `npx hardhat verify --network mainnet CONTRACT_ADDRESS ${argsString}`
  }

  private generateId(): string {
    return `contract_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}

// Utility functions for code generation
export function generateRemixFiles(contract: GeneratedContract): RemixDeployment {
  return {
    contractName: contract.name,
    sourceCode: contract.solidity,
    compilerVersion: '0.8.19',
    evmVersion: contract.configuration.evmVersion,
    optimization: {
      enabled: true,
      runs: contract.configuration.optimizationRuns
    },
    constructorArgs: contract.constructorParams,
    libraries: {}
  }
}

export function exportToRemix(contract: GeneratedContract): string {
  const remixData = generateRemixFiles(contract)
  
  // Generate Remix workspace JSON
  const workspace = {
    "contracts": {
      [`${contract.name}.sol`]: {
        content: remixData.sourceCode
      }
    },
    "settings": {
      "optimizer": {
        "enabled": remixData.optimization.enabled,
        "runs": remixData.optimization.runs
      },
      "evmVersion": remixData.evmVersion,
      "compilerVersion": remixData.compilerVersion
    }
  }
  
  return JSON.stringify(workspace, null, 2)
}

export function generateHardhatConfig(contract: GeneratedContract): string {
  return `require("@nomicfoundation/hardhat-toolbox");
require("@nomiclabs/hardhat-etherscan");

module.exports = {
  solidity: {
    version: "${contract.compiler}",
    settings: {
      optimizer: {
        enabled: true,
        runs: ${contract.configuration.optimizationRuns}
      },
      evmVersion: "${contract.configuration.evmVersion}"
    }
  },
  networks: {
    hardhat: {},
    mainnet: {
      url: process.env.MAINNET_URL || "",
      accounts: process.env.PRIVATE_KEY !== undefined ? [process.env.PRIVATE_KEY] : [],
    }
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};`
}
